# What are static references?
In Java, static variables belong to the class itself, not to any individual instance.
A static variable is loaded once when the class is loaded and lives for the entire lifetime of the 
program (or until the class is unloaded, which rarely happens in most applications).

# Why can static references cause memory leaks?
> Because static variables live so long, anything they reference is also kept alive in memory.
> If a static variable references large objects or collections (like a big List, Map, or custom objects),
> those objects cannot be garbage collected as long as the static variable holds the reference.
This can lead to memory leaks if those references are never cleared or properly managed.

public class Cache 
{
    // Static cache that lives for the entire application lifetime
    private static List<byte[]> dataCache = new ArrayList<>();

    public static void addData(byte[] data)
    {
        dataCache.add(data);
    }
}

Here, dataCache is static and will stay in memory until the application ends.
Every byte[] added to this cache cannot be garbage collected, even if you don't need it anymore.
If the cache keeps growing without any cleanup, the application’s memory usage grows indefinitely → memory leak.

# How to avoid leaks caused by static references?
Clear static collections when data is no longer needed:
dataCache.clear();
> Use weak references for caches so that objects can be GC’ed
  when no longer strongly referenced elsewhere.
> Avoid holding large objects or resources in static variables unless absolutely necessary.
> In web apps or modular systems, be careful with static references because they can prevent
  class unloading and cause classloader leaks.

